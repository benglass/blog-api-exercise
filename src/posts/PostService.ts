import { APIError } from "../core/APIError";

export type PostId = number;

export type Post = {
  id: number;
  title: string;
  contents: string;
  timeStamp: string;
  categoryId: number;
};

let posts = [
  {
    id: 1,
    title: "My excellent blog post",
    contents: "<p>Some HTML contents</p>",
    // TODO: Need to ensure server is using a reliable time zone (utc)
    timeStamp: new Date().toString(),
    // TODO: Where to persist categories?
    categoryId: 1,
  },
];

export class PostService {
  async getPostById(id: PostId): Promise<Post | null> {
    // TODO: Load the post from persistence
    const post = posts.find((p) => p.id === id);

    return post || null;
  }

  async getPosts(): Promise<Post[]> {
    // TODO: Get the from persistence/database
    return posts;
  }

  async createPost(postPartial: Partial<Post>): Promise<Post> {
    // TODO: Persist the post
    const post: Partial<Post> = {
      // TODO: Id would be generated by db
      id: posts.length + 1,
      title: postPartial.title,
      contents: postPartial.contents,
      categoryId: postPartial.categoryId,
      // TODO: timestamp ideally populated by DB
      timeStamp: new Date().toISOString(),
    };

    // TODO: Validation of presence/length of required
    // TODO: Validation of categoryId, or let it be enforced at the DB level
    // VAlidation would ensure that post is a valid Post type, so no need for "as Post"
    const newPost = post as Post;

    // TODO: Real persistence
    posts.push(newPost);

    // TODO: Might have to load from DB to get full post (if id/ts is populated by db)
    return newPost;
  }

  async updatePost(postPartial: Partial<Post>): Promise<Post> {
    // TODO: Make a better type for update that has id required
    const postToUpdate = await this.getPostById(postPartial.id as PostId);
    if (!postToUpdate) throw new APIError(404, "Could not find post");

    // Merge in existing fields
    const post: Partial<Post> = {
      ...postToUpdate,
      title: postPartial.title,
      contents: postPartial.contents,
      categoryId: postPartial.categoryId,
    };

    // TODO: Validation of presence/length of required
    // TODO: Validation of categoryId, or let it be enforced at the DB level
    // VAlidation would ensure that post is a valid Post type, so no need for "as Post"
    const updatedPost = post as Post;

    // TODO: Real persistence
    posts = posts.map((p) => {
      if (p.id === post.id) {
        return updatedPost;
      }

      return p;
    });

    // TODO: Might have to load from DB to get full post (if id/ts is populated by db)
    return updatedPost;
  }
}
